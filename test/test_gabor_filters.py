import unittest
import numpy as np
import cv2
import skimage.filters

from feature_extraction.gabor import GaborKernel

class TestGaborKernel(unittest.TestCase):
    def test_init(self):
        """Checks whether a gabor kernel can be initiated."""
        gabor = GaborKernel()
        self.assertIsInstance(gabor, GaborKernel)

    def test_parameter_TypeErrors(self):
        """Checks if parameter TypeErrors are raised"""
        self.assertRaises(TypeError, GaborKernel, sigma=np.array([1, 1, 1]))
        self.assertRaises(TypeError, GaborKernel, lamda=np.array([1, 1, 1]))
        self.assertRaises(TypeError, GaborKernel, psi=np.array([1, 1, 1]))
        self.assertRaises(TypeError, GaborKernel, theta=np.array([1, 1, 1]))
        self.assertRaises(TypeError, GaborKernel, amplitude=np.array([1, 1, 1]))
        self.assertRaises(TypeError, GaborKernel, n_stds=np.array([1, 1, 1]))

    def test_parameter_ValueErrors(self):
        """Checks if parameter ValueErrors are raised"""
        self.assertRaises(ValueError, GaborKernel, width=-1)
        self.assertRaises(ValueError, GaborKernel, lamda=0)
        self.assertRaises(ValueError, GaborKernel, amplitude=0)
        self.assertRaises(ValueError, GaborKernel, n_stds=-1)
        self.assertRaises(ValueError, GaborKernel, n_stds=3, width=1)

    def test_width_overwrite(self):
        """Checks if defining width overwrites the n_stds parameter while
        calculating kernel width"""
        for w in range(1, 10):
            kernel = GaborKernel(width=w)
            self.assertEqual(kernel.weights.shape, (w, w))

    def test_kernel_shape_with_default_n_stds(self):
        """Checks if kernel shape is correct, given sigma and default n_stds"""
        for sigma in range(1, 10):
            kernel = GaborKernel(sigma=sigma)
            w = (np.ceil(
                kernel.n_stds_default_value * kernel.sigma) * 2 + 1).astype(int)
            self.assertEqual(kernel.weights.shape, (w, w))

    def test_kernel_shape_with_given_n_stds(self):
        """Checks if kernel shape is correct, given sigma and default n_stds"""
        for sigma in range(1, 10):
            for n_stds in range(1, 10):
                kernel = GaborKernel(sigma=sigma, n_stds=n_stds)
                w = (np.ceil(kernel.n_stds * kernel.sigma) * 2 + 1).astype(int)
                self.assertEqual(kernel.weights.shape, (w, w))

    def test_compare_lava_to_opencv_implementation(self):
        """
        Check if Lava implementation of Gabor filters match the openCV
        implementation for psi (offset) = 0
        Notes:
            - OpenCV implementation does not have sigma and n_std dependent
            kernel size definition
            - OpenCV implementation always generates kernels with odd-sized width
            - There is implmentation difference between OpenCV and ours in
            Lava, regarding psi (offset)
              hence comparison only made with psi=0
            - This test checks if normalized euclidian distance between
            kernels  generated by openCV and our Lava implementation is less
            than 1e-6 or not. If not then this will not pass
            - Test includes large spectrum of values for all parameters (except psi)
        """
        psi = 0
        for ksize in range(3, 16, 4):
            for sigma in range(1, 4):
                for theta in np.arange(0, np.pi, np.pi / 8):
                    for lamda in np.logspace(-2, 2, num=5, base=2):
                        for gamma in np.logspace(-2, 2, num=5, base=2):
                            kernel_openCV = cv2.getGaborKernel((ksize, ksize),
                                                               sigma, theta,
                                                               lamda, gamma,
                                                               psi,
                                                               ktype=cv2.CV_32F)
                            kernel_lava = GaborKernel(ksize, sigma, theta,
                                                      lamda, gamma, psi).weights

                            dist = np.linalg.norm(kernel_openCV - kernel_lava)
                            self.assertLess(dist, 1e-6)

    def test_compare_lava_to_skimage_implementation(self):
        """
        Compare Lava implementation of Gabor kernels/filters to those of skimage.
        Notes:
         - As skimage does not allow to specify kernel size, we test n_std
         and sigma dependent sizing of kernels. In this case skimage
         implementation may generate rectangular kernels rather than square
         ones, while our Lava implementation generates always square. For
         this reason we test with only aspect ratio of 1 (gamma=1).
         - In addition note that skimage implementation asks for frequency
         rather than wavelength, hence frequency=1/lamda (where lamda is
         wavelength).
         - Skimage also scale weights of the generated kernels by dividing
         the kernel by "2 * np.pi * sigma_x * sigma_y". We scaled it back
         using this factor to be able to compare it to our implementation.
        """
        gamma = 1
        for sigma in range(1, 4):
            sigma_x = sigma_y = sigma
            scaling_skimage = 2 * np.pi * sigma_x * sigma_y
            for n_std in range(1, 8):
                for theta in np.arange(0, np.pi, np.pi / 8):
                    for lamda in np.logspace(-2, 2, num=5, base=2):
                        for psi in np.arange(0, 2 * np.pi, np.pi / 8):
                            ## skimage implementation. Note that frequency = 1/lamda
                            kernel_skimage = np.real(
                                skimage.filters.gabor_kernel(
                                    frequency=1 / lamda,
                                    theta=theta,
                                    sigma_x=sigma_x,
                                    sigma_y=sigma_y,
                                    offset=psi,
                                    n_stds=n_std))

                            # Lava implementation is scaled with skimage scaling
                            # factor = 2 * np.pi * sigma_x * sigma_y
                            # See the source code of skimage implementation
                            # for this scaling factor
                            kernel_lava = 1 / scaling_skimage * GaborKernel(
                                sigma=sigma,
                                theta=theta,
                                lamda=lamda,
                                gamma=gamma,
                                psi=psi,
                                n_stds=n_std).weights
                            dist = np.linalg.norm(kernel_skimage - kernel_lava)

                            self.assertAlmostEqual(dist, 0)

    def test_precision_of_compiled_weights_in_Nx(self):
        """
        Tests if relative error of compiled weights of Gabor filters compared
        to original kernel (float matrix) is below 0.03, i.e. 3 %
        Test goes through large number of params for Gabor filters and
        collects the relative errors in a list and finally
        checks if all error values (discrepancies) are below the accepted
        value (0.03 or 3%).
        Note: Amplitude is set at 255, so that the kernel values fall into
        range of [-255, 255], which is Loihi's weight range for MIXED synapses
        """
        # Gabor kernels with large range of parameters
        rel_errors_kernel = []
        psi = 0
        np.set_printoptions(suppress=True)
        for width in range(3, 16, 4):
            for sigma in range(1, 4):
                for theta in np.arange(0, np.pi, np.pi / 8):
                    for lamda in np.logspace(-2, 2, num=5, base=2):
                        for gamma in np.logspace(-2, 2, num=5, base=2):
                            param = {
                                    "width": width,
                                    "sigma": sigma,
                                    "theta": theta,
                                    "lamda": lamda,
                                    "psi": psi,
                                    "gamma": gamma,
                                    "amplitude": 255
                            }

                            # Instantiate the kernel
                            kernel = GaborKernel(**param)
                            kernel_shape = kernel.weights.shape

                            ## Input DNF
                            dnf_in = Population(shape=kernel_shape,
                                                threshold=10, tau_voltage=1,
                                                tau_current=1)

                            # Make the convolutional connection
                            conv2d, dnf_out = connect_conv(source=dnf_in,
                                                          kernel=kernel,
                                                          stride=(1,1),
                                                          tau_current=1)

                            # Calculate relative error
                            rel_error_kernel = \
                                calculate_precision_of_connection(
                                    conv2d, kernel)

                            # Add them to the lists
                            rel_errors_kernel.append(rel_error_kernel)

                            ## Comment in, if you want to see the weights
                            # print(np.around(kernel.weights.flatten(),decimals=1))
                            # print(conv2d.weights.value)
        # Plot histogram of relative errors if necessary
        # plt.hist(rel_errors_conn)
        # plt.show()
        # plt.hist(rel_errors_kernel)
        # plt.show()

        # Assert all error values are below 0.03
        self.assertTrue(all(i <= 0.03 for i in rel_errors_kernel))